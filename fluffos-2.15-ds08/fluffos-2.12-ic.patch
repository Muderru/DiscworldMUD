diff -rNu fluffos-2.12-ic-patched/ChangeLog.fluffos-2.x fluffos/ChangeLog.fluffos-2.x
--- fluffos-2.12-ic-patched/ChangeLog.fluffos-2.x	2008-07-08 09:45:15.166943000 -0400
+++ fluffos/ChangeLog.fluffos-2.x	2008-07-08 01:01:20.254753000 -0400
@@ -1,5 +1,10 @@
 As MudOS is moving too slow to keep our driver hacks apart, we now call our own
 FluffOS :)
+FluffOS 2.13:
+Added a console, mostly for debugging use.  If driver is started directly
+	 rather than through a script, add argument -C and it has a 
+        command-line.  try 'help'.  HAS_CONSOLE must be defined in
+        local_options. (hamlet)
 FluffOS 2.12:
 rework of ed to do larger output chunks, more configurability, and bugfixes:
 	mixed receive_ed(string msg, string fname) apply in playerob to 
diff -rNu fluffos-2.12-ic-patched/GNUmakefile fluffos/GNUmakefile
--- fluffos-2.12-ic-patched/GNUmakefile	2008-07-08 09:41:55.351273000 -0400
+++ fluffos/GNUmakefile	2008-07-08 09:33:49.665213000 -0400
@@ -74,7 +74,7 @@
   socket_efuns.c socket_ctrl.c qsort.c eoperators.c socket_err.c md.c \
   disassembler.c binaries.c uvalarm.c $(STRFUNCS) \
   replace_program.c master.c function.c \
-  debug.c crypt.c applies_table.c add_action.c eval.c fliconv.c
+  debug.c crypt.c applies_table.c add_action.c eval.c fliconv.c console.c
 
 all: $(OBJDIR) cc.h main_build
 main_build2: $(DRIVER_BIN) addr_server portbind
diff -rNu fluffos-2.12-ic-patched/GNUmakefile.in fluffos/GNUmakefile.in
--- fluffos-2.12-ic-patched/GNUmakefile.in	2008-07-08 09:41:58.184937000 -0400
+++ fluffos/GNUmakefile.in	2008-04-30 12:56:34.077917000 -0400
@@ -58,7 +58,7 @@
   socket_efuns.c socket_ctrl.c qsort.c eoperators.c socket_err.c md.c \
   disassembler.c binaries.c uvalarm.c $(STRFUNCS) \
   replace_program.c master.c function.c \
-  debug.c crypt.c applies_table.c add_action.c eval.c fliconv.c
+  debug.c crypt.c applies_table.c add_action.c eval.c fliconv.c console.c
 
 all: $(OBJDIR) cc.h main_build
 main_build2: $(DRIVER_BIN) addr_server portbind
diff -rNu fluffos-2.12-ic-patched/Makefile.in fluffos/Makefile.in
--- fluffos-2.12-ic-patched/Makefile.in	2008-07-08 09:41:56.456057000 -0400
+++ fluffos/Makefile.in	2008-04-30 12:56:18.734113000 -0400
@@ -61,7 +61,7 @@
   socket_efuns.c socket_ctrl.c qsort.c eoperators.c socket_err.c md.c \
   disassembler.c binaries.c uvalarm.c $(STRFUNCS) \
   replace_program.c ccode.c cfuns.c compile_file.c master.c function.c \
-  debug.c crypt.c applies_table.c add_action.c eval.c fliconv.c
+  debug.c crypt.c applies_table.c add_action.c eval.c fliconv.c console.c
 
 all: cc.h files main_build
 
diff -rNu fluffos-2.12-ic-patched/add_action.c fluffos/add_action.c
--- fluffos-2.12-ic-patched/add_action.c	2008-07-08 09:41:54.060489000 -0400
+++ fluffos/add_action.c	2008-04-17 14:40:52.740606000 -0400
@@ -227,7 +227,7 @@
 	return;
 
     debug(d_flag, ("Enable commands /%s (ref %d)",
-		   current_object->name, current_object->ref));
+		   current_object->obname, current_object->ref));
 
     if (num) {
 	current_object->flags |= O_ENABLE_COMMANDS;
@@ -266,7 +266,7 @@
     int where;
     int save_illegal_sentence_action;
     
-    debug(d_flag, ("cmd [/%s]: %s\n", command_giver->name, buff));
+    debug(d_flag, ("cmd [/%s]: %s\n", command_giver->obname, buff));
 
     /* strip trailing spaces. */
     for (p = buff + strlen(buff) - 1; p >= buff; p--) {
diff -rNu fluffos-2.12-ic-patched/comm.c fluffos/comm.c
--- fluffos-2.12-ic-patched/comm.c	2008-07-08 09:45:15.177956000 -0400
+++ fluffos/comm.c	2008-07-08 00:09:03.250964000 -0400
@@ -14,6 +14,7 @@
 #include "master.h"
 #include "add_action.h"
 #include "eval.h"
+#include "console.h"
 
 #define TELOPT_COMPRESS 85
 #define TELOPT_COMPRESS2 86
@@ -87,7 +88,7 @@
 static void start_compression (interactive_t *);
 static int send_compressed (interactive_t *ip, unsigned char* data, int length);
 
-
+extern void restore_sigttin(void);
 
 #ifdef NO_SNOOP
 #  define handle_snoop(str, len, who)
@@ -128,6 +129,10 @@
 interactive_t **all_users = 0;
 int max_users = 0;
 
+#ifdef HAS_CONSOLE
+int has_console = -1;
+#endif
+
 /*
  * private local variables.
  */
@@ -1400,6 +1405,11 @@
      */
     FD_ZERO(&readmask);
     FD_ZERO(&writemask);
+#ifdef HAS_CONSOLE
+    /* set up a console */
+    if(has_console > 0)
+      FD_SET(STDIN_FILENO, &readmask);
+#endif
     /*
      * set new user accept fd in readmask.
      */
@@ -1501,6 +1511,31 @@
             hname_handler();
         }
     }
+    
+#ifdef HAS_CONSOLE
+    /* Process console input */
+    /* Note: need the has_console on the next line because linux (at least)
+             recycles fds, even STDIN_FILENO
+    */
+    if((has_console > 0) && FD_ISSET(STDIN_FILENO, &readmask)) {
+      char s[1024];
+      int sz;
+
+      if((sz = read(STDIN_FILENO, s, 1023)) > 0) {
+        s[sz-1] = '\0';
+        console_command(s);
+      }
+      else if(sz == 0) {
+        printf("Console exiting.  The MUD remains.\n");
+        has_console = 0;
+      }
+      else {
+        printf("Console read error: %d %d.  Closing console.\n", sz, errno);
+        has_console = 0;
+        restore_sigttin();
+      }
+    }
+#endif
 }
 
 /*
diff -rNu fluffos-2.12-ic-patched/comm.h fluffos/comm.h
--- fluffos-2.12-ic-patched/comm.h	2008-07-08 09:41:57.099058000 -0400
+++ fluffos/comm.h	2008-07-08 00:07:46.486919000 -0400
@@ -177,6 +177,9 @@
 
 extern interactive_t **all_users;
 extern int max_users;
+#ifdef HAS_CONSOLE
+extern int has_console;
+#endif
 
 void CDECL add_vmessage (object_t *, const char *, ...);
 void add_message (object_t *, const char *, int);
diff -rNu fluffos-2.12-ic-patched/compiler.h fluffos/compiler.h
--- fluffos-2.12-ic-patched/compiler.h	2008-07-08 09:41:56.256204000 -0400
+++ fluffos/compiler.h	2008-04-27 14:26:14.173427000 -0400
@@ -109,7 +110,7 @@
 extern unsigned short *comp_def_index_map;
 extern unsigned short *func_index_map;
 
-typedef struct compiler_temp_t {
+typedef struct compiler_temp_s {
     unsigned short flags;
     unsigned short offset;
     unsigned short function_index_offset;
@@ -118,7 +119,7 @@
         function_t *func;
         long index;
     } u;
-    struct compiler_temp_t *next;
+    struct compiler_temp_s *next;
 } compiler_temp_t;
 
 /*
diff -rNu fluffos-2.12-ic-patched/console.c fluffos/console.c
--- fluffos-2.12-ic-patched/console.c	1969-12-31 19:00:00.000000000 -0500
+++ fluffos/console.c	2008-07-08 00:53:05.431408000 -0400
@@ -0,0 +1,292 @@
+/*
+ *  console.c -- implements a command-line for the driver.
+ *               Separate file because this is likely to grow with time.
+ *               Note that the intent is NOT to have a full scripting language,
+ *               since that's, er, what LPC is.  This is to implement driver
+ *               inspection that is difficult or impossible from inside the
+ *               mud.  Because of this, explicit allocation of things is
+ *               probably a bad idea: use automatic stack variables as much
+ *               as is possible.
+ *               Isaac Charles (Hamlet@Discworld, etc) -- Jul 2008
+ */
+
+#include "std.h"
+
+#ifdef HAS_CONSOLE
+#include "comm.h"
+#include "object.h"
+#include "dumpstat.h"
+
+#define NAME_LEN 50
+
+typedef struct {
+  char name[NAME_LEN + 1];
+  int cpy;
+  int ref;
+  long mem;
+  long idle;
+} ITEMS;
+  
+static int strcmpalpha(const char *aname, const char *bname);
+static int objcmpalpha(const void *, const void *);
+static int itemcmpsize(const void *, const void *);
+static int objcmpsize(const void *, const void *);
+static int objcmpidle(const void *, const void *);
+
+static INLINE void print_obj(int refs, int cpy, const char *obname, long lastref, 
+                             long sz) {
+  printf("%4d %4d %-*s %5ld %10ld\n", refs, cpy, NAME_LEN, 
+                                    obname, ((long)time(0) - lastref), sz);
+}
+
+void console_command(char *s) {
+  char verb[11];
+  char args[2][11];
+  int numargs, num[2];
+  
+  if(strlen(s) > 0) {
+    if(strncmp(s, "quit", strlen(s)) == 0) {
+      (void) puts("Console closing.  The mud remains.");
+      //(void) fclose(stdin);
+      has_console = 0;
+      restore_sigttin();
+    }
+    else if(strncmp(s, "shutdown", ((strlen(s) > 4) ? strlen(s) : 4)) == 0) {
+      (void) puts("Mud ending now.");
+      shutdownMudOS(0);
+      return;
+    }
+    else if(strncmp(s, "help", strlen(s)) == 0) {
+      (void) puts(
+"Console Help\n\
+    quit       Close the console (the MUD remains)\n\
+    shutdown   End the mud (rapidly)\n\
+    help       This.\n\
+    objects    Show a listing of all active objects.  Format:\n\
+               objects [qualifier] [val|range]\n\
+               qualifiers are:\n\
+                 alpha    sort objects alphabetically\n\
+                 size     sort objects by (reverse) size\n\
+                 idle     sort objects by (reverse) idle time\n\
+                 totals   sum together usage of all clones of an obj and\n\
+                          display in reverse order of size\n\
+               val is a number, specifying number of objects to show,\n\
+               from the beginning (positive) or from the end (negative).\n\
+               range is st..fin where st and fin can be number of objects\n\
+               from the beginning (positive) or from the end (negative.)\
+");
+    }
+    else { // commands that can be followed by args
+      num[0] = 0;
+      num[1] = INT_MAX;
+      
+      if((numargs = sscanf(s, "%10s %10s %10s", verb, args[0], args[1]) - 1) 
+         >= 1) {
+        int tmp;
+        char *pos = args[numargs-1];
+        
+        while((pos = strchr(pos, '<')) != NULL)
+          *pos++ = '-';
+        
+        if((tmp = sscanf(args[numargs-1], "%d..%d", &num[0], &num[1])) == 2) {
+        }
+        else if(tmp == 1) {
+          if(args[numargs-1][strlen(args[numargs-1])-1] != '.') {
+            if(num[0] == 0) {
+              num[0] = num[1] = 0;
+            }
+            else if(num[0] > 0) {
+              num[1] = num[0] - 1;
+              num[0] = 0;
+            }
+          }
+        }
+        
+        if(tmp)
+          numargs--;              
+      }
+        
+      if(strncmp(verb, "objects", strlen(verb)) == 0) {
+        object_t **list;
+        int count;
+        int i;
+        long totsz = 0, sz;
+        char TOTALS = (char) 0;
+  
+        // get_objects() allocates a string and pushes it onto the stack.
+        // probably not a problem here as long as we remember to pop it.
+        get_objects(&list, &count, 0, 0);
+
+        if(numargs) {
+          if(strncmp("alpha", args[0], strlen(args[0])) == 0)
+            qsort(list, (size_t) count, sizeof(object_t *), objcmpalpha);
+          else if(strncmp("size", args[0], strlen(args[0])) == 0)
+            qsort(list, (size_t) count, sizeof(object_t *), objcmpsize);
+          else if(strncmp("idle", args[0], strlen(args[0])) == 0)
+            qsort(list, (size_t) count, sizeof(object_t *), objcmpidle);
+          else { /* This should be "totals" */
+            TOTALS = (char) 1;
+            qsort(list, (size_t) count, sizeof(object_t *), objcmpalpha);
+          }
+        }
+        
+        printf("%4s %4s %-*s %5s %10s\n", "Rf", "Cpy", NAME_LEN, "Obj", 
+                                          "Idle", "Size");
+          
+        if(TOTALS && (count > 1)) {
+          ITEMS it[count+1];
+          int lst = 0;
+          char *pound;
+          //char tmpnam[NAME_LEN + 1];
+          
+          memset(it, 0, (count+1) * sizeof(ITEMS));
+
+          for(i=0; i < count; i++) {
+            if(strcmpalpha(it[lst].name, list[i]->obname)
+               != 0) {
+              lst++;
+            
+              strncpy(it[lst].name, list[i]->obname + 
+                                    ((strlen(list[i]->obname) > NAME_LEN) ?
+                                     (strlen(list[i]->obname) - NAME_LEN) : 0)
+                                  , NAME_LEN);
+              pound = strchr(it[lst].name, '#');
+              if(pound != NULL)
+                *pound = '\0';
+            }
+              
+            it[lst].cpy++;
+            it[lst].ref += list[i]->ref;
+            it[lst].mem += list[i]->prog->total_size + data_size(list[i]) +
+                           sizeof(object_t);
+            if(((long)list[i]->time_of_ref < it[lst].idle) || !it[lst].idle)
+              it[lst].idle = (long) list[i]->time_of_ref;
+          }
+          
+          qsort(it+1, (size_t) lst, sizeof(ITEMS), itemcmpsize);
+
+          if(num[0] >= lst)
+            num[0] = lst - 1;
+          else if(num[0] < 0) {
+            num[0] = lst + num[0];
+            if(num[0] < 0)
+              num[0] = 0;
+          }
+          num[0]++;
+          
+          if(num[1] >= lst)
+            num[1] = lst - 1;
+          else if(num[1] < 0) {
+            num[1] = lst + num[1];
+            if(num[1] < 0)
+              num[1] = 0;
+          }
+          num[1]++;
+          
+          for(i=num[0]; i<=num[1]; i++) {
+            print_obj(it[i].ref, it[i].cpy, it[i].name, it[i].idle, 
+                       it[i].mem);
+            totsz += it[i].mem;
+          }
+        }
+        else { // no totals needed
+          if(num[0] >= count)
+            num[0] = count - 1;
+          else if(num[0] < 0) {
+            num[0] = count + num[0];
+            if(num[0] < 0)
+              num[0] = 0;
+          }
+          if(num[1] >= count)
+            num[1] = count - 1;
+          else if(num[1] < 0) {
+            num[1] = count + num[1];
+            if(num[1] < 0)
+              num[1] = 0;
+          }
+        
+          for(i = num[0]; i <= num[1]; i++) {
+            print_obj((int)list[i]->ref, 1, list[i]->obname, 
+                      (long) list[i]->time_of_ref,
+                      sz = (long) list[i]->prog->total_size + 
+                           (long)data_size(list[i]) +
+                           (long)sizeof(object_t));
+            totsz += sz;
+          }
+        }
+
+        printf("%4s %4s %-*s %5s %10s\n", "", "", NAME_LEN, "-----", "-----", 
+                                           "----------");
+        printf("%4s %4s %*d %-5s %10ld\n", "", "", NAME_LEN, 1+num[1]-num[0], 
+                                          "objs", totsz);
+        pop_stack();
+      }
+      else {
+        (void) puts("Unknown command.");
+      }
+    }
+  }
+  
+  if(has_console > 0) {
+    (void) putchar('?'); (void) putchar(' ');
+    (void) fflush(stdout);
+  }
+}
+
+static int strcmpalpha(const char *aname, const char *bname) {
+  for(;(*aname == *bname) && (*aname != '#') && (*bname != '#') &&
+       (*aname != '\0') && (*bname != '\0'); aname++, bname++); /* ; */
+  
+  if(*aname == '#') {
+    if((*bname != '#') && (*bname != '\0'))
+      return 1;
+    return 0;
+  }
+  if(*bname == '#') {
+    if(*aname == '\0')
+      return 0;
+    return -1;
+  }
+  
+  return (int) (*aname - *bname);
+}
+
+static int objcmpalpha(const void *a, const void *b) {
+  const char *aname = (*((object_t **) a))->obname;
+  const char *bname = (*((object_t **) b))->obname;
+
+  return strcmpalpha(aname, bname);
+}
+
+static int itemcmpsize(const void *a, const void *b) {
+  long asz = (*((ITEMS *) a)).mem;
+  long bsz = (*((ITEMS *) b)).mem;
+  
+  if(asz == bsz)
+    return strcmpalpha((*((ITEMS *) a)).name, (*((ITEMS *) b)).name);
+  
+  return (int) (bsz - asz);
+}
+
+static int objcmpsize(const void *a, const void *b) {
+  object_t *aobj = (*((object_t **) a));
+  object_t *bobj = (*((object_t **) b));
+  int asz = aobj->prog->total_size + data_size(aobj);
+  int bsz = bobj->prog->total_size + data_size(bobj);
+  
+  if(asz == bsz)
+    return objcmpalpha(a, b);
+    
+  return bsz - asz;
+}
+
+static int objcmpidle(const void *a, const void *b) {
+  int arft = (*((object_t **) a))->time_of_ref;
+  int brft = (*((object_t **) b))->time_of_ref;
+  
+  if(arft == brft)
+    return objcmpalpha(a, b);
+    
+  return arft - brft;
+}
+#endif
diff -rNu fluffos-2.12-ic-patched/console.h fluffos/console.h
--- fluffos-2.12-ic-patched/console.h	1969-12-31 19:00:00.000000000 -0500
+++ fluffos/console.h	2008-07-08 00:48:27.206602000 -0400
@@ -0,0 +1,16 @@
+/*
+ * console.h -- definitions and prototypes for console.c
+ *
+ */
+
+#ifndef CONSOLE_H
+#define CONSOLE_H
+
+#include "options_incl.h"
+
+#ifdef HAS_CONSOLE
+extern void console_command(char *);
+#endif
+
+#endif
+
diff -rNu fluffos-2.12-ic-patched/ed.c fluffos/ed.c
--- fluffos-2.12-ic-patched/ed.c	2008-07-08 09:45:15.328942000 -0400
+++ fluffos/ed.c	2008-05-12 23:53:03.393042000 -0400
@@ -498,7 +498,7 @@
 
 /*      doprnt.c        */
 static int doprnt (int from, int to)
-{   svalue_t *ret;
+{   
 #if (BUFFER_SIZE) > (ED_MAXLINE)
     char outbf[BUFFER_SIZE];
 #else
diff -rNu fluffos-2.12-ic-patched/local_options fluffos/local_options
--- fluffos-2.12-ic-patched/local_options	2008-07-08 09:41:58.538775000 -0400
+++ fluffos/local_options	2008-07-08 00:37:11.483780000 -0400
@@ -593,6 +593,16 @@
  */
 #define REF_RESERVED_WORD
 
+/* HAS_CONSOLE: If defined, the driver can take the argument -C
+ *   which will give the driver an interactive console (you can type
+ *   commands at the terminal.)  Backgrounding the driver will turn off
+ *   the console, but sending signal SIGTTIN (kill -21) to the driver can
+ *   turn it back on.  Typing 'help' will display commands available.
+ *   The intent is to allow the inspection of things that are difficult
+ *   to inspect from inside the mud.
+ */
+#define HAS_CONSOLE
+
 /****************************************************************************
  *                              PACKAGES                                    *
  *                              --------                                    *
diff -rNu fluffos-2.12-ic-patched/macros.h fluffos/macros.h
--- fluffos-2.12-ic-patched/macros.h	2008-07-08 09:41:58.138920000 -0400
+++ fluffos/macros.h	2008-05-19 15:16:10.450235000 -0400
@@ -216,7 +216,7 @@
 #endif
 
 #ifndef _FUNC_SPEC_
-   char *xalloc (int);
+   char *xalloc (size_t);
 #  ifdef DEBUGMALLOC
       char *int_string_copy (const char * const, char *);
       char *int_string_unlink (const char *, char *);
diff -rNu fluffos-2.12-ic-patched/main.c fluffos/main.c
--- fluffos-2.12-ic-patched/main.c      2008-07-08 09:41:55.659199000 -0400
+++ fluffos/main.c      2008-07-08 10:53:16.080149000 -0400
@@ -24,11 +24,11 @@
 int max_cost;
 int time_to_clean_up;
 const char *default_fail_message;
-int boot_time;
+long boot_time;
 int max_array_size;
 int max_buffer_size;
 int max_string_length;
-static int reserved_size;
+static size_t reserved_size;
 char *reserved_area;    /* reserved for MALLOC() */
 static char *mud_lib;

@@ -49,6 +49,9 @@

 static void CDECL sig_fpe SIGPROT;
 static void CDECL sig_cld SIGPROT;
+#ifdef HAS_CONSOLE
+static void CDECL sig_ttin SIGPROT;
+#endif

 #ifdef TRAP_CRASHES
 static void CDECL sig_usr1 SIGPROT;
@@ -127,8 +130,8 @@
      * Check that the definition of EXTRACT_UCHAR() is correct.
      */
     p = (char *) &i;
-    *p = -10;
-    if (EXTRACT_UCHAR(p) != 0x100 - 10) {
+    *p = (char) -10;
+    if (EXTRACT_UCHAR(p) != (unsigned char) (0x100 - 10)) {
   fprintf(stderr, "Bad definition of EXTRACT_UCHAR() in interpret.h.\n");
   exit(-1);
     }
@@ -234,7 +237,7 @@
 #endif
     time_to_clean_up = TIME_TO_CLEAN_UP;
     max_cost = MAX_COST;
-    reserved_size = RESERVED_SIZE;
+    reserved_size = (size_t) RESERVED_SIZE;
     max_array_size = MAX_ARRAY_SIZE;
     if(max_array_size > 65535){
       fprintf(stderr, "Maximum array size can not exceed 65535");
@@ -246,7 +249,7 @@
     set_inc_list(INCLUDE_DIRS);
     if (reserved_size > 0)
   reserved_area = (char *) DMALLOC(reserved_size, TAG_RESERVED, "main.c: reserved_area");
-    for (i = 0; i < sizeof consts / sizeof consts[0]; i++)
+    for (i = 0; i < (int) (sizeof consts / sizeof consts[0]); i++)
   consts[i] = exp(-i / 900.0);
     reset_machine(1);
     /*
@@ -272,6 +275,11 @@
   case 'N':
       no_ip_demon++;
       continue;
+#ifdef HAS_CONSOLE
+  case 'C':
+      has_console = 1;
+      continue;
+#endif
 #ifdef YYDEBUG
   case 'y':
       yydebug = 1;
@@ -332,6 +340,7 @@
       case 'N':
       case 'm':
       case 'y':
+      case 'C':
     continue;
       case 'f':
     save_context(&econ);
@@ -425,6 +434,13 @@
     signal(SIGCLD, sig_cld);
 #endif
 #endif
+
+#ifdef HAS_CONSOLE
+    if(has_console >= 0)
+      signal(SIGTTIN, sig_ttin);
+    signal(SIGTTOU, SIG_IGN);
+#endif
+
     backend();
     return 0;
 }
@@ -439,7 +455,7 @@
     int len;

     DEBUG_CHECK(!str, "Null string passed to string_copy.\n");
-    len = strlen(str);
+    len = (int) strlen(str);
     if (len > max_string_length) {
   len = max_string_length;
   p = new_string(len, desc);
@@ -464,7 +480,7 @@
     mbt->ref--;

     if (mbt->size == USHRT_MAX) {
-  int l = strlen(str + USHRT_MAX) + USHRT_MAX; /* ouch */
+  size_t l = strlen(str + USHRT_MAX) + USHRT_MAX; /* ouch */

   newmbt = (malloc_block_t *)DXALLOC(l + sizeof(malloc_block_t) + 1, TAG_MALLOC_STRING, desc);
   memcpy((char *)(newmbt + 1), (char *)(mbt + 1), l+1);
@@ -495,9 +511,10 @@
    * check whether config file specified this option
    */
   if (strlen(DEBUG_LOG_FILE))
-      sprintf(deb, "%s/%s", LOG_DIR, DEBUG_LOG_FILE);
+      snprintf(deb, 1023, "%s/%s", LOG_DIR, DEBUG_LOG_FILE);
   else
-      sprintf(deb, "%s/debug.log", LOG_DIR);
+      snprintf(deb, 1023, "%s/debug.log", LOG_DIR);
+  deb[1023] = '\0';
   while (*deb == '/')
       deb++;
   debug_message_fp = fopen(deb, "w");
@@ -522,7 +539,8 @@

 int slow_shut_down_to_do = 0;

-char *xalloc (int size)
+/*@null@*/
+char *xalloc (size_t size)
 {
     char *p;
     const char *t;
@@ -570,6 +588,38 @@
     signal(SIGFPE, sig_fpe);
 }

+#ifdef HAS_CONSOLE
+void restore_sigttin(void) {
+  if(has_console >= 0)
+    signal(SIGTTIN, sig_ttin);
+}
+
+/* The console goes to sleep when backgrounded and can
+ * be woken back up with kill -SIGTTIN <pid>
+ */
+static void CDECL PSIG(sig_ttin)
+{   char junk[1024];
+    int fl;
+
+    has_console = !has_console;
+
+    signal(SIGTTIN, SIG_IGN);
+
+    if(has_console) {
+      /* now eat all the gibberish they typed in the console when it was dead */
+      fl = fcntl(STDIN_FILENO, F_GETFL);
+      fcntl(STDIN_FILENO, F_SETFL, fl | O_NONBLOCK);
+
+      while(read(STDIN_FILENO, junk, 1023) > 0);  /* ; */
+
+      /* leaving the output nonblocking is a bad idea.  large outputs tend
+         to get truncated.
+      */
+      fcntl(STDIN_FILENO, F_SETFL, fl);
+    }
+}
+#endif
+
 #ifdef TRAP_CRASHES

 /* send this signal when the machine is about to reboot.  The script
diff -rNu fluffos-2.12-ic-patched/main.h fluffos/main.h
--- fluffos-2.12-ic-patched/main.h	2008-07-08 09:41:56.429057000 -0400
+++ fluffos/main.h	2008-05-19 14:53:02.984152000 -0400
@@ -34,7 +34,7 @@
 extern int comp_flag;
 extern int time_to_clean_up;
 extern const char *default_fail_message;
-extern int boot_time;
+extern long boot_time;
 extern int max_cost;
 extern int max_array_size;
 extern int max_buffer_size;
diff -rNu fluffos-2.12-ic-patched/mapping.h fluffos/mapping.h
--- fluffos-2.12-ic-patched/mapping.h	2008-07-08 09:41:54.464345000 -0400
+++ fluffos/mapping.h	2008-05-19 14:14:01.085058000 -0400
@@ -10,17 +10,17 @@
 #include "hash.h"
 #include "stralloc.h"
 //#define MAP_SVAL_HASH(x) (((POINTER_INT)((x).u.number)) >> 5)
-static long sval_hash(svalue_t x){
+static unsigned long sval_hash(svalue_t x){
     switch(x.type)
     {
         case T_STRING:
             return HASH(BLOCK(x.u.string));
         case T_NUMBER:
-            return x.u.number;
+            return (unsigned long) x.u.number;
         case T_OBJECT:
             //return HASH(BLOCK(x.u.ob->obname));
         default:
-            return (((POINTER_INT)((x).u.number)) >> 5);
+            return ((unsigned long)((POINTER_INT)((x).u.number)) >> 5);
     }
 }
 
diff -rNu fluffos-2.12-ic-patched/md.c fluffos/md.c
--- fluffos-2.12-ic-patched/md.c	2008-07-08 09:41:54.211486000 -0400
+++ fluffos/md.c	2008-05-05 12:21:05.303808000 -0400
@@ -8,6 +8,7 @@
 #include "simul_efun.h"
 #include "call_out.h"
 #include "mapping.h"
+#include "simulate.h"
 #if defined(PACKAGE_SOCKETS) || defined(PACKAGE_EXTERNAL)
 #include "socket_efuns.h"
 #endif
diff -rNu fluffos-2.12-ic-patched/object.c fluffos/object.c
--- fluffos-2.12-ic-patched/object.c	2008-07-08 09:41:56.288199000 -0400
+++ fluffos/object.c	2008-06-27 00:02:43.466401000 -0400
@@ -1880,6 +1880,7 @@
     tot_alloc_object++;
     tot_alloc_object_size += size;
     ob = (object_t *) DXALLOC(size, TAG_OBJECT, "get_empty_object");
+
     /*
      * marion Don't initialize via memset, this is incorrect. E.g. the bull
      * machines have a (char *)0 which is not zero. We have structure
diff -rNu fluffos-2.12-ic-patched/options.h fluffos/options.h
--- fluffos-2.12-ic-patched/options.h	2008-07-08 09:45:15.378944000 -0400
+++ fluffos/options.h	2008-07-08 00:36:41.822008000 -0400
@@ -592,6 +592,16 @@
  */
 #define REF_RESERVED_WORD
 
+/* HAS_CONSOLE: If defined, the driver can take the argument -C
+ *   which will give the driver an interactive console (you can type
+ *   commands at the terminal.)  Backgrounding the driver will turn off
+ *   the console, but sending signal SIGTTIN (kill -21) to the driver can
+ *   turn it back on.  Typing 'help' will display commands available.
+ *   The intent is to allow the inspection of things that are difficult
+ *   to inspect from inside the mud.
+ */
+#define HAS_CONSOLE
+ 
 /****************************************************************************
  *                              PACKAGES                                    *
  *                              --------                                    *
diff -rNu fluffos-2.12-ic-patched/packages/parser.c fluffos/packages/parser.c
--- fluffos-2.12-ic-patched/packages/parser.c	2008-07-08 09:41:54.763349000 -0400
+++ fluffos/packages/parser.c	2008-05-05 12:10:08.755911000 -0400
@@ -1014,7 +1014,7 @@
     return he;
 }
 
-void mark_hash_entry (char * str) {
+void mark_hash_entry (const char * str) {
     int h = DO_HASH(str, HASH_SIZE);
     hash_entry_t *he;
 
diff -rNu fluffos-2.12-ic-patched/program.h fluffos/program.h
--- fluffos-2.12-ic-patched/program.h	2008-07-08 09:41:57.734914000 -0400
+++ fluffos/program.h	2008-06-26 17:25:04.514186000 -0400
@@ -200,7 +200,7 @@
     unsigned short flags;
     unsigned short last_inherited;
     unsigned short ref;                 /* Reference count */
-    unsigned short func_ref;
+    unsigned int func_ref;
 #ifdef DEBUG
     int extra_ref;              /* Used to verify ref count */
     int extra_func_ref;
diff -rNu fluffos-2.12-ic-patched/simulate.c fluffos/simulate.c
--- fluffos-2.12-ic-patched/simulate.c	2008-07-08 09:45:15.405946000 -0400
+++ fluffos/simulate.c	2008-06-26 17:04:32.928304000 -0400
@@ -525,10 +525,10 @@
 
 static char *make_new_name (const char * str)
 {
-    static int i;
-    char *p = (char *)DXALLOC(strlen(str) + 10, TAG_OBJ_NAME, "make_new_name");
+    static unsigned int i;
+    char *p = (char *)DXALLOC(strlen(str) + 12, TAG_OBJ_NAME, "make_new_name");
 
-    (void) sprintf(p, "%s#%d", str, i);
+    (void) sprintf(p, "%s#%u", str, i);
     i++;
     return p;
 }
diff -rNu fluffos-2.12-ic-patched/smalloc.c fluffos/smalloc.c
--- fluffos-2.12-ic-patched/smalloc.c	2008-07-08 09:41:56.428059000 -0400
+++ fluffos/smalloc.c	2008-05-17 12:22:44.890022000 -0400
@@ -108,7 +108,7 @@
 static char *esbrk (u);
 static int resort_free_list (void);
 #ifdef DEBUG
-static void walk_new_small_malloced (void (* ()));
+static void walk_new_small_malloced (void (*func) (POINTER, int));
 #endif
 
 #define s_size_ptr(p)	(p)
@@ -1041,7 +1041,7 @@
     static char *current_break = 0;
 
     if (current_break == 0)
-	current_break = sbrkx(0);
+	current_break = (char *) sbrkx(0);
     if (brk(current_break + size) == -1)
 	return 0;
 
@@ -1414,7 +1414,6 @@
 /*
  * Functions below can be used to debug malloc.
  */
-
 static void walk_new_small_malloced(func)
     void (*func) (POINTER, int);
 {
diff -rNu fluffos-2.12-ic-patched/sprintf.c fluffos/sprintf.c
--- fluffos-2.12-ic-patched/sprintf.c	2008-07-08 09:41:55.685199000 -0400
+++ fluffos/sprintf.c	2008-05-22 09:57:25.466973000 -0400
@@ -509,7 +509,7 @@
             break;
         }
     default:
-        outbuf_add(outbuf, "!ERROR: GARBAGE SVALUE!");
+        outbuf_addv(outbuf, "!ERROR: GARBAGE SVALUE: %x!", obj->type);
     }                           /* end of switch (obj->type) */
     if (trailing)
         outbuf_add(outbuf, ",\n");
diff -rNu fluffos-2.12-ic-patched/std.h fluffos/std.h
--- fluffos-2.12-ic-patched/std.h	2008-07-08 09:41:57.412928000 -0400
+++ fluffos/std.h	2008-05-05 14:12:43.754910000 -0400
@@ -31,6 +31,10 @@
 #endif
 #include "debug.h"
 
+#ifdef DEBUGMALLOC_EXTENSIONS
+#   define DEBUG
+#endif
+
 #endif
 
 
diff -rNu fluffos-2.12-ic-patched/std_incl.h fluffos/std_incl.h
--- fluffos-2.12-ic-patched/std_incl.h	2008-07-08 09:41:50.550910000 -0400
+++ fluffos/std_incl.h	2008-05-19 15:04:50.054760000 -0400
@@ -1,6 +1,8 @@
 #if !defined(STD_INCL_H) && !defined(_FUNC_SPEC_)
 #define STD_INCL_H
 
+#include "configure.h"
+
 #ifdef INCL_STDLIB_H
 #  include <stdlib.h>
 #endif
@@ -117,7 +119,7 @@
 
 /* Note: This is now only used if _both_ USHRT_MAX and MAXSHORT fail to exist*/
 #ifndef USHRT_MAX
-#define USHRT_MAX ((1 << (sizeof(short)*8)) - 1)
+#define USHRT_MAX ((unsigned short)((1 << (sizeof(unsigned short)*8)) - 1))
 #endif
 
 #endif
